# Syslog 収集パイプライン
# UDP 514 および TCP 514（コンテナ内部ポート 5140）でSyslogを受信し
# Elasticsearch に転送する

input {
  # UDP Syslog 受信（RFC 3164 / BSD Syslog 形式）
  udp {
    port  => 5140
    codec => plain { charset => "UTF-8" }
    type  => "syslog"
    tags  => ["syslog", "udp"]
  }

  # TCP Syslog 受信（信頼性が求められるホスト向け）
  tcp {
    port  => 5140
    codec => plain { charset => "UTF-8" }
    type  => "syslog"
    tags  => ["syslog", "tcp"]
  }
}

filter {
  if [type] == "syslog" {
    # RFC 3164 Syslog メッセージをパース
    # 例: <PRI>Mmm DD HH:MM:SS hostname program[pid]: message
    grok {
      match => {
        "message" => [
          # PRI + タイムスタンプ + ホスト + プログラム[PID]: メッセージ
          "<%{POSINT:syslog_pri}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\\[%{POSINT:syslog_pid}\\])?: %{GREEDYDATA:syslog_message}",
          # PRI なし（一部デバイス向け）
          "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\\[%{POSINT:syslog_pid}\\])?: %{GREEDYDATA:syslog_message}"
        ]
      }
      tag_on_failure => ["_grokparsefailure_syslog"]
    }

    # Syslog Priority から Facility と Severity を計算
    if [syslog_pri] {
      ruby {
        code => "
          pri = event.get('syslog_pri').to_i
          event.set('syslog_facility_code', pri / 8)
          event.set('syslog_severity_code', pri % 8)

          facilities = [
            'kernel', 'user', 'mail', 'daemon', 'security', 'syslog',
            'lpr', 'news', 'uucp', 'clock', 'security2', 'ftp', 'ntp',
            'audit', 'alert', 'clock2', 'local0', 'local1', 'local2',
            'local3', 'local4', 'local5', 'local6', 'local7'
          ]
          severities = [
            'emergency', 'alert', 'critical', 'error',
            'warning', 'notice', 'informational', 'debug'
          ]

          event.set('syslog_facility', facilities[pri / 8] || 'unknown')
          event.set('syslog_severity', severities[pri % 8] || 'unknown')
        "
      }
    }

    # タイムスタンプを正規化（年がないRFC 3164向け）
    if [syslog_timestamp] {
      date {
        match       => ["syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss"]
        target      => "@timestamp"
        timezone    => "Asia/Tokyo"
        tag_on_failure => ["_dateparsefailure_syslog"]
      }
    }

    # 元のメッセージフィールドを整理
    mutate {
      rename  => { "syslog_message" => "message_parsed" }
      add_field => { "[@metadata][index_prefix]" => "syslog" }
      remove_field => ["syslog_pri"]
    }
  }
}

output {
  if [type] == "syslog" {
    elasticsearch {
      # Elasticsearch クラスターへ出力（es01 をエントリポイントとして使用）
      hosts    => ["https://es01:9200"]
      user     => "elastic"
      password => "${ELASTIC_PASSWORD}"

      # TLS 設定（setupサービスが生成したCA証明書を使用）
      # Logstash 9.x では ssl_verification_mode は "full" または "none" のみ有効
      ssl_enabled                    => true
      ssl_certificate_authorities    => ["/usr/share/logstash/config/certs/ca/ca.crt"]
      ssl_verification_mode          => "full"

      # 日付ベースのインデックス（例: syslog-2026.02.17）
      index => "syslog-%{+YYYY.MM.dd}"

      # インデックステンプレート設定
      manage_template  => true
      template_name    => "syslog"
      template_overwrite => false
    }
  }

  # デバッグ用（必要に応じてコメント解除）
  # stdout {
  #   codec => rubydebug
  # }
}
